Исследуйте исходный код и принципы работы 3 утилит на ваш выбор:

> -       одной из лекции про low-hanging fruits (*httprobe, wpscan, etc.*)
>
> \-       одной из лекций про фаззинг (*gobuster, hakrawler, etc.*)
>
> \-       одной из лекций про уязвимости (*sqlmap, sstimap, etc.*)
>
> По результатам анализа определите, по каким характерным артефактам в логах веб-сервера можно понять, что атакующий использует эту утилиту. Примерами артефактов могут быть: предсказуемые пути и параметры запросов, заголовок User-Agent и т.д. Напишите регулярное выражение для артефакта.
>
> Опишите, необходимо ли для получения этих артефактов менять конфигурацию логирования по умолчанию для apache, nginx. 
>
> Опишите, что необходимо сделать атакующему, чтобы избежать появления такого артефакта при работе – добавить параметр запуска, изменить исходный код программы и т.д.
>
> Постарайтесь определить несколько артефактов для каждой утилиты и предположить, возможно ли появление таких артефактов в рамках обычной работы пользователей. 
>
> Утилиты для фаззинга и их артефакты можно рассматривать вместе с поставляемыми словарями, если такие имеются.
>
> Итого, для трех утилит нужно предоставить:
>
> 1. Артефакты работы в виде описания и регулярных выражений. Регулярные выражения не должны вызывать частых False Positive.
> 2. Необходимость изменения конфигурации веб-сервера для выявления артефактов. Необходимо привести требуемый итоговый фрагмент конфигурации, если изменения необходимы.
> 3. Что требуется изменить атакующему, чтобы избежать указанных в п.1 артефактов.
>
> Если выбранная утилита не оставляет явных артефактов, выберите другую.
>
> Чтобы удобно выявлять артефакты, можно поднять у себя nginx/apache, и атаковать их.


Для анализа возьмем набор инструментов: httprobe, gobuster, sqlmap. Подготовим среду для анализа, поставим базовую конфигурацию nginx сервера и запустим его. Первая утилита на очереди httprobe. Выполним запрос типа: echo “example.com“ | httprobe:

 ![](/api/attachments.redirect?id=635b51d1-ec72-42c3-8a0c-ae4cc5ec3a40 "aspect=1")

Сразу перейдем в логи и просмотрим потенциальные артефакты, которые могла оставить эта утилита.
 ![](/api/attachments.redirect?id=06918a21-19bf-499b-8ac0-cb4f95e686b4 "aspect=1")

 ![](/api/attachments.redirect?id=7786b713-e611-4c5d-8257-4b9190be4202 "aspect=1")


Совмещая данные о возможностях утилиты и логе, который был записан, мы можем написать регулярное выражение для анализа входящего запроса, которое найдет артефакты c настройками по дефолту:

- **Стандартный метод GET;**
- **Не классический Useragent;**
- **Всегда обращается по стандартному пути / и использует протокол HTTP версии 1.1.**

  Правило Reg:

\[^curl/7.88.1$\] AND \[^\\/ HTTP\\/1\\.1$\] AND \[^GET$\]

Артефакты с “**Стандартный метод GET” и “Всегда обращается по стандартному пути / и использует протокол HTTP версии 1.1”** являются косвенными и вполне могут быть легитимным запросом, поэтому они должны быть в правиле в сочетании с **curl/7.88.1**, более явно наводящим на факт использования **httprobe**. Хотя и при таком сценарии нельзя исключать, что могут быть фолзы, однако, не такие частые при условии версии протокола и версии curl, которые из самого ПО не меняются опциями.

Изменений в конфигурации логирования не требуется.

Для того, чтобы избежать детектирования, нарушитель может поменять метод запроса, а остальные параметры, так как уже захардкожены необходимо переписывать и заново компилировать код, где будет иной useragent и возможность выбора версии протокола.

Вторая утилита gobuster может выполнять функции enum DNS/file/dir, но мы рассмотрим фаззинг с помощью данной утилиты.

gobuster fuzz -u http://example.com/FUZZ -w /path/to/wordlist.txt

 ![](/api/attachments.redirect?id=8057a279-ec34-4e3a-9937-d01d8f9275e3 "aspect=1")

Сетевой пакет:

 ![](/api/attachments.redirect?id=944f7cdc-2373-4fe3-a261-732f3689b27f "aspect=1")

Проанализируем его возможности и найдем артефакты:

 ![](/api/attachments.redirect?id=24aad9eb-a0e0-4420-bd31-e09c8e1e570d "aspect=1")


- **Не классический Useragent;**
- **Словарь пэйлоадов в URL-строке: <https://github.com/1N3/IntruderPayloads/tree/master/FuzzLists> = PAYLOAD**
- **Протокол HTTP 1.1**
- **Метод архивирования gzip**

REg rule

\[^gobuster\\/3\\.5$\] AND \[^HTTP\\/1\\.1$\] AND \[^PAYLOAD$\] AND \[^gzip$\]

Много фолзов быть не должно, даже без агента, так как PAYLOAD становится явным индикатором, если совпадает gzip и версией HTTP 1.1 

Лог конфиг менять не нужно, так как уже логируется путь обращения 

 ![](/api/attachments.redirect?id=92804f63-c961-40e6-b8d8-4f73dbb50bd3 "aspect=1")

Для обхода нарушитель может изменить агент на любой легитимный Google, Safari и тд, переписать ПО и использовать иные версии протокола, метод архивации, а так же найти или сформировать свой пэйлоад для атаки, который не встречается в публичных списках.

**Третья утилита sqlmap** позволяет проводит автоматизированную инъекцию на сервис. 

  ![](/api/attachments.redirect?id=d0f9ca4e-0d94-4ed1-83ba-654214703623 "aspect=1")


Проанализируем поступивший пакет

 ![](/api/attachments.redirect?id=cb989555-ad99-471a-9a2b-bbf8fa2330dd "aspect=1")

И возможности утилиты
 ![](/api/attachments.redirect?id=9e9aa8f9-c10c-4032-bb32-c758a8730f3f "aspect=1")

- **Не классический Useragent;**
- **Артефакты в URL-строке по идентификации БД, а так же пэйлоады, можно составить словарь: <https://github.com/1N3/IntruderPayloads/blob/master/FuzzLists/sqli-time-based.txt> = PAYLOAD**
-  **Connection: close**

  Атакующий указывает Connection: close, чтобы сервер сразу завершил соединение, не предоставив возможность быстро отследить активное соединение.

**REg rule**

\[^sqlmap\\/1\\.7\\.2\\#stable$\] AND \[^PAYLOAD$\] AND \[^Connection: close$\]


**Изменим стандартный лог** и добавим сбор `http_connection`

`log_format custom_format '$remote_addr - $remote_user [$time_local] '`

`                         '"$request" $status $body_bytes_sent '`

`                         '"$http_connection" "$http_user_agent"';`


Нарушитель может изменить useragent + Обход фильтров ввода + 

**Hex в котором закодирована иньекция для обхода проверки по сигнатуре**:

`SELECT \* FROM users WHERE username=0x61646d696e;`

\+ 

SQLmap поддерживает опцию --tamper, которая автоматически изменяет запросы, чтобы обойти WAF. 

`sqlmap -u "http://example.com?id=1" --tamper=space2comment`

`sqlmap -u "http://example.com?id=1" --tamper=between`



